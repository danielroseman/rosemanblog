<!DOCTYPE html>
<html lang="en">
<head>
        <title>Django patterns, part 2: efficient reverse lookups</title>
        <meta charset="utf-8" />
        <link rel="stylesheet" href="../../.././theme/css/main.css" type="text/css" />
        <link href="../../.././feeds/all.atom.xml" type="application/atom+xml" rel="alternate" title="rosemanblog ATOM Feed" />
        
        <link href="../../.././feeds/all.xml" type="application/atom+xml" rel="alternate" title="rosemanblog RSS Feed" />
        

        <!--[if IE]>
                <script src="http://html5shiv.googlecode.com/svn/trunk/html5.js"></script><![endif]-->

        <!--[if lte IE 7]>
                <link rel="stylesheet" type="text/css" media="all" href="../../.././css/ie.css"/>
                <script src="../../.././js/IE8.js" type="text/javascript"></script><![endif]-->

        <!--[if lt IE 7]>
                <link rel="stylesheet" type="text/css" media="all" href="../../.././css/ie6.css"/><![endif]-->

</head>

<body id="index" class="home">

        <header id="banner" class="body">
                <h1><a href="../../../.">rosemanblog </a></h1>
                <nav><ul>
                
                
                
                
                
                    <li class="active"><a href="../../.././category/Technical.html">Technical</a></li>
                
                </ul></nav>
        </header><!-- /#banner -->
                
<section id="content" class="body">    
<article>
        <header> <h1 class="entry-title"><a href=""
        rel="bookmark" title="Permalink to Django patterns, part 2: efficient reverse lookups">Django patterns, part 2: efficient reverse lookups</a></h1> 
<a href="http://twitter.com/share" class="twitter-share-button" data-count="horizontal" data-via="danielroseman">Tweet</a><script type="text/javascript" src="http://platform.twitter.com/widgets.js"></script>
 </header>
        <div class="entry-content">
        <footer class="post-info">
        <abbr class="published" title="2010-01-11T09:07:33">
                Mon 11 January 2010
        </abbr>

        
        <address class="vcard author">
                By <a class="url fn" href="../../.././author/Daniel Roseman.html">Daniel Roseman</a>
        </address>
        
<p>In <a href="../../.././category/Technical.html">Technical</a>. </p>
<p>tags: <a href="../../.././tag/django.html">django</a> <a href="../../.././tag/patterns.html">patterns</a> <a href="../../.././tag/foreignkey.html">foreignkey</a> <a href="../../.././tag/query-efficiency.html">query-efficiency</a> </p>


</footer><!-- /.post-info -->
        <p>One of the main sources of unnecessary database queries in Django applications is reverse relations.</p>
<p>By default, Django doesn't do anything to follow relations across models. This means that unless you're careful, any relationship can lead to extra hits on the database. For instance, assuming MyModel has a ForeignKey to MyRelatedModel, this:</p>
<div class="codehilite"><pre><span class="n">myobj</span> <span class="o">=</span> <span class="n">MyModel</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">pk</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="k">print</span> <span class="n">myobj</span><span class="o">.</span><span class="n">myrelatedmodel</span><span class="o">.</span><span class="n">name</span>
</pre></div>


<p>hits the database two separate times - once to get the MyModel object, and once to get the related MyRelatedModel object. Luckily, it's easy to get Django to optimise this into a single call:</p>
<div class="codehilite"><pre><span class="n">myobj</span> <span class="o">=</span> <span class="n">MyModel</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">select_related</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">pk</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
</pre></div>


<p>This way Django does a JOIN in the database call, and caches the related object in a hidden attribute of myobj. Printing <code>myobj.__dict__</code> will show this:</p>
<div class="codehilite"><pre><span class="p">{</span><span class="s">&#39;_myrelatedmodel_cache&#39;</span><span class="p">:</span> <span class="p">[</span><span class="n">MyRelatedModel</span><span class="p">:</span> <span class="n">obj</span><span class="p">],</span>
 <span class="s">&#39;name&#39;</span><span class="p">:</span> <span class="s">&#39;My name&#39;</span><span class="p">}</span>
</pre></div>


<p>Now, whenever you call <code>myobj.myrelatedmodel</code>, Django automatically uses the version in <code>_myrelatedmodel_cache</code> rather than going back to the database to get it. Note that this is exactly the same as what happens once the the related object was accessed in the first snippet above - Django caches it in the same way for future use. All <code>select_related()</code> does is pre-cache it before the first access.</p>
<p>None of this is new - it's quite well explained in the Django documentation. However, what's not obvious is how to do the same for reverse relationships. In other words, this:</p>
<div class="codehilite"><pre><span class="n">myrelatedobj</span> <span class="o">=</span> <span class="n">MyRelatedObject</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">pk</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="k">print</span> <span class="n">myrelatedobj</span><span class="o">.</span><span class="n">mymodel_set</span><span class="o">.</span><span class="n">all</span><span class="p">()</span>
</pre></div>


<p>Here you'll always get two separate db calls, and adding <code>select_related()</code> anywhere won't help at all. Now one extra db call isn't that significant, but consider this in a template:</p>
<div class="codehilite"><pre><span class="nt">&lt;ul&gt;</span>
<span class="cp">{%</span> <span class="k">for</span> <span class="nv">obj</span> <span class="k">in</span> <span class="nv">myobjects</span> <span class="cp">%}</span>
    <span class="nt">&lt;li&gt;</span><span class="cp">{{</span> <span class="nv">myobj.name</span> <span class="cp">}}</span><span class="nt">&lt;/li&gt;</span>
    <span class="nt">&lt;ul&gt;</span>
         <span class="cp">{%</span> <span class="k">for</span> <span class="nv">relobj</span> <span class="k">in</span> <span class="nv">myobj.backwardsrelationship_set.all</span> <span class="cp">%}</span>
         <span class="nt">&lt;li&gt;</span><span class="cp">{{</span> <span class="nv">relobj.name</span> <span class="cp">}}</span><span class="nt">&lt;/li&gt;</span>
         <span class="cp">{%</span> <span class="k">endfor</span> <span class="cp">%}</span>
    <span class="nt">&lt;/ul&gt;</span>
<span class="cp">{%</span> <span class="k">endfor</span> <span class="cp">%}</span>
<span class="nt">&lt;/ul&gt;</span>
</pre></div>


<p>Not an unreasonable thing to want to do - iterate through a bunch of objects, then for each one display all the objects in its backwards relationship. However, this will always cost n+1 queries, where n is the number of objects in the <code>myobjects</code> queryset. And what's worse, Django will go back and get the items from the database each time they're accessed, even if we've already got them for the same object in the same view or template. The queries quickly mount up. So how can we optimise this?</p>
<p>The answer is to get all the related objects at once, for the entire queryset, then cache each object's related objects in a hidden attribute. We can do this by sorting the objects once we've got them into a dict, keyed by the id of their parent object:</p>
<div class="codehilite"><pre><span class="n">qs</span> <span class="o">=</span> <span class="n">MyRelatedObject</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">all</span><span class="p">()</span>
<span class="n">obj_dict</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">([(</span><span class="n">obj</span><span class="o">.</span><span class="n">id</span><span class="p">,</span> <span class="n">obj</span><span class="p">)</span> <span class="k">for</span> <span class="n">obj</span> <span class="ow">in</span> <span class="n">qs</span><span class="p">])</span>
<span class="n">objects</span> <span class="o">=</span> <span class="n">MyObject</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="n">myrelatedobj__in</span><span class="o">=</span><span class="n">qs</span><span class="p">)</span>
<span class="n">relation_dict</span> <span class="o">=</span> <span class="p">{}</span>
<span class="k">for</span> <span class="n">obj</span> <span class="ow">in</span> <span class="n">objects</span><span class="p">:</span>
    <span class="n">relation_dict</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="n">obj</span><span class="o">.</span><span class="n">myobject_id</span><span class="p">,</span> <span class="p">[])</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span>
<span class="k">for</span> <span class="nb">id</span><span class="p">,</span> <span class="n">related_items</span> <span class="ow">in</span> <span class="n">relation_dict</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
    <span class="n">obj_dict</span><span class="p">[</span><span class="nb">id</span><span class="p">]</span><span class="o">.</span><span class="n">_related_items</span> <span class="o">=</span> <span class="n">related_items</span>
</pre></div>


<p>Now each MyRelatedObject instance in <code>qs</code> has a <code>_related_items</code> attribute, containing all the MyObject items in its reverse relationship. Obviously, since Django doesn't know about this, the only way to get the items is to explicitly iterate through <code>_related_items</code> rather than <code>myobject_set.all</code> in the template. And if you need extra filtering, you need to do it in the view where you first get the objects, since the resulting attribute isn't a queryset and can't be filtered.</p>
<p>There's quite a bit of looping etc in this snippet, so you should probably profile carefully to ensure this isn't actually more expensive than just going back to the database. But I've found that this is fairly efficient, and saves a lot of database access.</p>
        </div><!-- /.entry-content -->
        
        <div class="comments">
        <h2>Comments !</h2>
            <div id="disqus_thread"></div>
            <script type="text/javascript">
               var disqus_identifier = "2010/01/11/django-patterns-part-2-efficient-reverse-lookups/";
               (function() {
               var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
               dsq.src = 'http://rosemanblog.disqus.com/embed.js';
               (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
              })();
            </script>
        </div>
        

</article>
</section>

        <section id="extras" class="body">
        
        
                <div class="social">
                        <h2>social</h2>
                        <ul>
                            <li><a href="../../.././feeds/all.atom.xml" rel="alternate">atom feed</a></li>
                            
                            <li><a href="../../.././feeds/all.xml" rel="alternate">rss feed</a></li>
                            

                        
                            <li><a href="http://twitter.com/danielroseman">twitter</a></li>
                        
                            <li><a href="http://github.com/danielroseman">github</a></li>
                        
                        </ul>
                </div><!-- /.social -->
        
        </section><!-- /#extras -->

        <footer id="contentinfo" class="body">
                <address id="about" class="vcard body">
                Proudly powered by <a href="http://alexis.notmyidea.org/pelican/">pelican</a>, which takes great advantages of <a href="http://python.org">python</a>.
                </address><!-- /#about -->

                <p>The theme is by <a href="http://coding.smashingmagazine.com/2009/08/04/designing-a-html-5-layout-from-scratch/">Smashing Magazine</a>, thanks!</p>
        </footer><!-- /#contentinfo -->




<script type="text/javascript">
    var disqus_shortname = 'rosemanblog';
    (function () {
        var s = document.createElement('script'); s.async = true;
        s.type = 'text/javascript';
        s.src = 'http://' + disqus_shortname + '.disqus.com/count.js';
        (document.getElementsByTagName('HEAD')[0] || document.getElementsByTagName('BODY')[0]).appendChild(s);
    }());
</script>

</body>
</html>