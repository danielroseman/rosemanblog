<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>rosemanblog</title><link href="http://blog.roseman.org.uk" rel="alternate"></link><link href="http://blog.roseman.org.uk/feeds/tags/group-by.xml" rel="self"></link><id>http://blog.roseman.org.uk</id><updated>2010-05-10T11:50:44+01:00</updated><entry><title>Django aggregation and a simple GROUP BY</title><link href="http://blog.roseman.org.uk/2010/05/10/django-aggregation-and-simple-group/" rel="alternate"></link><updated>2010-05-10T11:50:44+01:00</updated><author><name>Daniel Roseman</name></author><id>http://blog.roseman.org.uk/2010/05/10/django-aggregation-and-simple-group/</id><summary type="html">&lt;p&gt;I love Django's aggregation framework. It very successfully abstracts the common aggregration tasks into a Pythonic syntax that sits extremely well with the rest of the ORM, and the documentation explains it all without a single reference to SQL.&lt;/p&gt;
&lt;p&gt;But sometimes that very abstraction gets in the way of working out what you want to do. One example of this happened to me today when I needed to do a sum of values grouped by a single value on a model - in SQL terms, a simple &lt;code&gt;GROUP BY&lt;/code&gt; query.&lt;/p&gt;
&lt;p&gt;The documentation is very clear about how to do aggregations across an entire QuerySet, and annotations across a relationship. So you can, for example, easily do a sum of all the 'value' fields in a model, or a sum of all the 'value' fields on a related model for each instance of the parent model. But the implication is that these are the only things you can do. So I was left wondering if I had to create a dummy related model just to contain the unique values of the field I wanted to group on.&lt;/p&gt;
&lt;p&gt;In fact, what I wanted to do &lt;em&gt;was&lt;/em&gt; &lt;a href="http://docs.djangoproject.com/en/1.1/topics/db/aggregation/#values"&gt;clearly documented&lt;/a&gt;, but because of the (probably correct) desire not to express things in terms of SQL, it's not that easy to find. So here's how to do it: you just need to use &lt;code&gt;values&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;For instance, my model is a set of transactions for a financial accounting system. Each transaction is associated with an order, which is just an integer ID referring to records in a completely different system. I wanted to get the total of transactions for each unique order ID. It's as simple as this:&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="n"&gt;Transaction&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;objects&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;values&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;order_id&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;annotate&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;total&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;Sum&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;value&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Which gives you a &lt;code&gt;ValuesQuerySet&lt;/code&gt; along the lines of:&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="p"&gt;[{&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;order_id&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="il"&gt;12345L&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;total&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;Decimal&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;1.23&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;)},&lt;/span&gt; 
 &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;order_id&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="il"&gt;54321L&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;total&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;Decimal&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;2.34&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;)},&lt;/span&gt; 
 &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;order_id&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="il"&gt;56789L&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;total&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;Decimal&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;3.45&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;)}]&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;One thing to be aware of: as the docs do note, the order of &lt;code&gt;values&lt;/code&gt; and &lt;code&gt;annotate&lt;/code&gt; is significant here. This way round, it groups by the fields listed in &lt;code&gt;values&lt;/code&gt; and then annotates. But if you put &lt;code&gt;annotate&lt;/code&gt; first, it does the calculation for each individual record, without grouping, then uses &lt;code&gt;values&lt;/code&gt; to simply restrict the fields it outputs.&lt;/p&gt;</summary><category term="django"></category><category term="aggregation"></category><category term="ORM"></category><category term="group-by"></category></entry></feed>