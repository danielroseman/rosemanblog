<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>rosemanblog</title><link href="http://blog.roseman.org.uk" rel="alternate"></link><link href="http://blog.roseman.org.uk/feeds/tags/vim.xml" rel="self"></link><id>http://blog.roseman.org.uk</id><updated>2013-12-17T11:15:00+00:00</updated><entry><title>A better vim 'go to declaration' with ASTs.</title><link href="http://blog.roseman.org.uk/2013/12/17/a-better-vim-go-to-declaration-with-asts/" rel="alternate"></link><updated>2013-12-17T11:15:00+00:00</updated><author><name>Daniel Roseman</name></author><id>http://blog.roseman.org.uk/2013/12/17/a-better-vim-go-to-declaration-with-asts/</id><summary type="html">&lt;p&gt;There are loads of little commands in vim for navigating around your files. One of the ones I like the most is &lt;code&gt;gd&lt;/code&gt;, for "go to local declaration". What that does - or is supposed to do - is find the place at which the identifier under the cursor is declared or defined, and go to it. &lt;/p&gt;
&lt;p&gt;However, as the documentation states, this is "not guaranteed to work" - and in fact rarely does. The issue is that vim does not parse the code and find the actual definition: what it does it to find the beginning of the current function (which rarely works in Python anyway) or the top of the file, and search forward from there. Even if that did work reliably, it still wouldn't cope with definitions at class or module level, and doesn't distinguish between variables defined at different scopes.&lt;/p&gt;
&lt;p&gt;No doubt the proper fix here is to use something like ctags, that processes your file and outputs a tags list that can be used by vim's tag matching. But that still wouldn't really understand scope. Anyway, I wanted to see if this could be done dynamically, by using Python itself to try and extract some meaning from the code, and determine where the variable was actually defined using its understanding of the scope. So, in my insanity, I turned to ASTs.&lt;/p&gt;
&lt;p&gt;&lt;a href="http://docs.python.org/2/library/ast.html"&gt;Abstract Syntax Trees&lt;/a&gt; are a way of representing code as a series of objects, arranged in a tree, which represent the language's grammar in an abstract way. Given this simple code:&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;foo&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;bar&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
  &lt;span class="n"&gt;baz&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;bar&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;
  &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;baz&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;and calling &lt;code&gt;ast.parse()&lt;/code&gt; on it (as a string), you get this series of objects (reformatted for clarity):&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="n"&gt;Module&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;body&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;FunctionDef&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;
    &lt;span class="n"&gt;name&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;foo&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
    &lt;span class="n"&gt;args&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;arguments&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;
        &lt;span class="n"&gt;args&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;Name&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;id&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;bar&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;ctx&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;Param&lt;/span&gt;&lt;span class="p"&gt;())],&lt;/span&gt;
        &lt;span class="n"&gt;vararg&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="bp"&gt;None&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;kwarg&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="bp"&gt;None&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;defaults&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="p"&gt;[]),&lt;/span&gt;
    &lt;span class="n"&gt;body&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;
        &lt;span class="n"&gt;Assign&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;
            &lt;span class="n"&gt;targets&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;Name&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;id&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;baz&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;ctx&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;Store&lt;/span&gt;&lt;span class="p"&gt;())],&lt;/span&gt;
            &lt;span class="n"&gt;value&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;BinOp&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;
                &lt;span class="n"&gt;left&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;Name&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;id&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;bar&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;ctx&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;Load&lt;/span&gt;&lt;span class="p"&gt;()),&lt;/span&gt;
                &lt;span class="n"&gt;op&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;Mult&lt;/span&gt;&lt;span class="p"&gt;(),&lt;/span&gt;
                &lt;span class="n"&gt;right&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;Num&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;n&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
        &lt;span class="p"&gt;),&lt;/span&gt;
        &lt;span class="n"&gt;Return&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;value&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;Name&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;id&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;baz&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;ctx&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;Load&lt;/span&gt;&lt;span class="p"&gt;()))&lt;/span&gt;
    &lt;span class="p"&gt;],&lt;/span&gt; &lt;span class="n"&gt;decorator_list&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="p"&gt;[]&lt;/span&gt;
&lt;span class="p"&gt;)])&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;That's not particularly easy to read, but you can at least see that it's represented the various identifiers - foo, bar and baz - as objects with attributes defining things like their names, and that the objects form a tree with the Module at the top, a FunctionDef inside that, and then the Assign and Return statements inside the body attribute.&lt;/p&gt;
&lt;p&gt;So, it looks like we can use this tree to find the definition of the variable we're on. The process will look like this: first, we need to scan through the tree to find our current file position and locate the AST representation of our current identifier. Then, we need to progressively widen our scope until we find the object that first assigns that identifier. Finally, we can move vim's cursor to that object's position.&lt;/p&gt;
&lt;p&gt;The code for doing this is borrowed mainly from the excellent pyflakes project, which uses AST parsing to detect syntax or style errors. (The vim interface code is inspired by the much-lamented pyflakes.vim - I've never got on with Syntastic in quite the same way I did with that). Pyflakes already does a great job of implementing a Visitor class to step through the tree and call relevant methods for each node, so all we need to do is override the relevant methods to search for our identifier, rather than check for style.&lt;/p&gt;
&lt;p&gt;Pyflakes also very helpfully keeps track of an object's scope. It uses this to check for errors like identifiers being referenced before they have been defined, or style issues like objects that are defined but never referenced. So, every time the visitor encounters a new definition, it stores it in a dictionary representing the current scope (module, function or class), and whenever it encounters a further use of that identifier, it looks the object up in the scope stack and annotates it with the scope where it was found.&lt;/p&gt;
&lt;p&gt;Clearly, that is exactly what we need to implement our 'go to definition' functionality. We just need to override the Visitor methods such that we compare each node with our identifier, and if they match we take that node, find its scope (which has already been recorded by the visitor) and then extract the definition's line/column number from there. Note that when matching, we compare both name and line number - clearly, names can be defined multiple times in a file, and we want the correct node for our target position.&lt;/p&gt;
&lt;p&gt;Things are complicated slightly by the fact that our target identifier might not be a Node at all, but an attribute of another node. This happens with dot notation: for example, the attribute reference &lt;code&gt;foo.quux&lt;/code&gt; is represented in an AST like this:&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="n"&gt;Attribute&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;value&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;Name&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;id&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;baz&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;ctx&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;Load&lt;/span&gt;&lt;span class="p"&gt;()),&lt;/span&gt; &lt;span class="n"&gt;attr&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;quux&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;ctx&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;Load&lt;/span&gt;&lt;span class="p"&gt;())&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;If you were searching for the original definition of the &lt;code&gt;quux&lt;/code&gt; attribute, you would need to start from the Attribute node and check for matches to the &lt;code&gt;attr&lt;/code&gt; attribute.&lt;/p&gt;
&lt;p&gt;We deal with this by overriding both &lt;code&gt;handleChildren&lt;/code&gt; and &lt;code&gt;NAME&lt;/code&gt; methods from Pyflake's Checker class. The first is called for attributes, and the second for Name nodes, ie everything else. In each one we check the line number, as well as either the &lt;code&gt;id&lt;/code&gt; or the &lt;code&gt;attr&lt;/code&gt; atribute.&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;handleChildren&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;tree&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;hasattr&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;tree&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;lineno&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="ow"&gt;and&lt;/span&gt; &lt;span class="n"&gt;tree&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;lineno&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;lineno&lt;/span&gt;
        &lt;span class="ow"&gt;and&lt;/span&gt; &lt;span class="nb"&gt;hasattr&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;tree&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;attr&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="ow"&gt;and&lt;/span&gt; &lt;span class="n"&gt;tree&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;attr&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;name&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
            &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;target&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;tree&lt;/span&gt;
            &lt;span class="n"&gt;scope&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;getScope&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;tree&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;attr&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
            &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;targetScope&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;scope&lt;/span&gt;

    &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="n"&gt;node&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="n"&gt;checker&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;iter_child_nodes&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;tree&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
        &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;handleNode&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;node&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;tree&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;NAME&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;node&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="nb"&gt;super&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;MyChecker&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;NAME&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;node&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;node&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;lineno&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;lineno&lt;/span&gt; &lt;span class="ow"&gt;and&lt;/span&gt; &lt;span class="n"&gt;node&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;id&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;name&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
      &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;target&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;node&lt;/span&gt;
      &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;targetScope&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;getScope&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;node&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;id&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;The &lt;code&gt;getScope&lt;/code&gt; method is a simple check upwards through the relevant scope objects:&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;getScope&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;target&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;target&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;scope&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
        &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;scope&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;target&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
    &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="n"&gt;scope&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;scopeStack&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;::&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;]:&lt;/span&gt;
        &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;target&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="n"&gt;scope&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
            &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;scope&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;target&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
    &lt;span class="k"&gt;print&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;Sorry, no definition found.&amp;#39;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;All that's left is the wrapper to grab the word under the vim cursor using &lt;code&gt;vim.eval('expand("&amp;lt;cword&amp;gt;")')&lt;/code&gt;, pass it to the Checker, extract the target definition, and go to the relevant line/column. One last tiny tweak is that not all nodes have an actual child node for the definition itself - eg the FunctionDef above starts on col 0, but the name itself is on col 4 - so we use a simply Python &lt;code&gt;str.find&lt;/code&gt; to move to the actual column position of the name.&lt;/p&gt;
&lt;p&gt;Now, of course this is still very far from perfect. It won't resolve names imported via &lt;code&gt;from module import *&lt;/code&gt; - but of course no-one would ever use that anyway. Much more seriously though, it can't find names that are defined outside the current scope tree. For example, if you call a method that defines a series of attributes on an object, then return it, and &lt;em&gt;then&lt;/em&gt; pass it to another method, inside that second method the scope chain has no record of where the new attributes were originally defined. Similarly, it won't find methods that are defined on an object's superclass. I haven't yet come up with any good way of fixing that, although in practice it doesn't seem to be a huge problem.&lt;/p&gt;
&lt;p&gt;You can find the code on &lt;a href="http://github.com/danielroseman/pygd-vim"&gt;GitHub&lt;/a&gt;.&lt;/p&gt;</summary><category term="python"></category><category term="vim"></category><category term="ast"></category></entry><entry><title>Improving the vim terminal development environment</title><link href="http://blog.roseman.org.uk/2012/02/04/improving-vim-terminal-development-environment/" rel="alternate"></link><updated>2012-02-04T14:21:27+00:00</updated><author><name>Daniel Roseman</name></author><id>http://blog.roseman.org.uk/2012/02/04/improving-vim-terminal-development-environment/</id><summary type="html">&lt;p&gt;Since I started working at Google, I've been doing almost all my development using vim through the terminal. Since &lt;a href="/2010/12/15/macvim-terminal-vim/"&gt;my last post&lt;/a&gt; on the subject (over a year ago - bad blogger), I've discovered some significant improvements to what I recommended there, and I thought I'd share what I've learned.&lt;/p&gt;
&lt;p&gt;The biggest improvement is to switch to &lt;a href="http://www.iterm2.com/"&gt;iTerm2&lt;/a&gt; as my terminal - thanks to &lt;a href="http://rosslawley.co.uk/"&gt;Ross&lt;/a&gt; for the recommendation. Not only does it remove the need for the TerminalColors hack, it also supports mouse events natively - so the MouseTerm hack is no longer needed. Plus, it includes support for control codes that change the cursor shape, so it is now simple to get vim to show whether it's in normal or insert mode. Just add these lines to &lt;code&gt;.vimrc&lt;/code&gt;:&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="k"&gt;let&lt;/span&gt; &amp;amp;&lt;span class="nb"&gt;t_SI&lt;/span&gt; &lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;\&amp;lt;Esc&amp;gt;]50;CursorShape=1\x7&amp;quot;&lt;/span&gt;
&lt;span class="k"&gt;let&lt;/span&gt; &amp;amp;&lt;span class="nb"&gt;t_EI&lt;/span&gt; &lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;\&amp;lt;Esc&amp;gt;]50;CursorShape=0\x7&amp;quot;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;The latest version of iTerm2 has another trick up its sleeve. It integrates seamlessly with a custom version of &lt;a href="http://tmux.sourceforge.net/"&gt;tmux&lt;/a&gt;, the terminal multiplexer that's an alternative to GNU Screen. Using any mulitplexer allows you to connect to a remote server with a single connection, and open as many tabs/windows to that connection as you like - and, what's more, you can detach your session when you log out and re-attach later, bringing your terminals back exactly how you left them. Useful enough, but what iTerm2 adds is native support for tmux tabs and windows - so that they open as tabs/windows on the Mac desktop, and you can switch between them using normal Mac shortcuts rather than tmux-specific ones. Very useful: it involves compiling a custom version of tmux and some associated libraries on the server, but it's well worth it.&lt;/p&gt;
&lt;p&gt;One missing element was the ability to cut-and-paste directly from vim into apps running on the Mac. This was tricky to get right.&lt;/p&gt;
&lt;p&gt;The basic principle is for the X clipboard to be shared with the OS X pasteboard, and then to to get vim to yank/delete to that clipboard. To get this working, I needed to run an X server on my Mac and enable clipboard sharing - it needs to be running for this, even if you're not using any X applications. There is an X11 app supplied with OS X, but (on Snow Leopard at least) it didn't seem to support the correct settings. Although it might be possible to get it working with some use of &lt;code&gt;defaults write&lt;/code&gt;, the easier solution is to use the open-source &lt;a href="http://xquartz.macosforge.org/trac/wiki"&gt;XQuartz&lt;/a&gt; project - it's the same as the supplied X11.app, but updated more frequently. The version that Google had, luckily, already installed on my machine (2.7.0) includes a Pasteboard tab on the Preferences dialog which controls syncing between Mac Pasteboard and X clipboard - you need to tick "Enable syncing", "Update Pasteboard when CLIPBOARD changes", and "Update CLIPBOARD when Pasteboard changes".&lt;/p&gt;
&lt;p&gt;The next step is to ensure that the SSH connection to the development machine uses X forwarding, which simply means using &lt;code&gt;ssh -X&lt;/code&gt; when connecting. If the remote machine/VM is headless, it may not have any of the X stuff installed: installing the &lt;code&gt;xauth&lt;/code&gt; package is probably enough to bring in the necessary dependencies, but I'm definitely not an expert here.&lt;/p&gt;
&lt;p&gt;Now, in vim, you can yank to the X clipboard by using the &lt;code&gt;+&lt;/code&gt; register, using &lt;code&gt;"+y&lt;/code&gt; - I now have this mapped to Ctrl-C, which is close enough to the Mac's default of Cmd-C that I find it easy to remember. In bleeding-edge versions of vim later than 7.3.74, there is actually an additional option that you can use so that all yanks go directly to the X clipboard: &lt;code&gt;set clipboard=unnamedplus&lt;/code&gt;. But I found that this ignores the difference between line-wise and character-wise selection, treating everything as character-wise, so cutting and pasting full lines inside vim becomes unnecessarily annoying. Better to learn the extra shortcut for those times when I explicitly need to copy out of vim.&lt;/p&gt;
&lt;p&gt;One final update to my last post: I talked there about switching between tabs, but I've now stopped using tabs altogether. Seriously, folks, if you're using vim, learn about buffers: they are great. Especially with the latest version of Command-T which allows you to use the same fuzzy-matching search to switch between open buffers using &lt;code&gt;&amp;lt;leader&amp;gt;b&lt;/code&gt;. Another advantage of buffers over tabs is that it allows you to have multiple windows open simultaneously in the same session: &lt;code&gt;Ctrl-w v&lt;/code&gt; splits the main window horizontally, and &lt;code&gt;Ctrl-w w&lt;/code&gt; switches between open windows (I've actually remapped Tab in normal mode to this). With a large monitor coupled with Google's &lt;em&gt;extremely&lt;/em&gt; strict 80-character limit, you can easily have two or three files next to each other. A real productivity boost.&lt;/p&gt;</summary><category term="vim"></category><category term="iterm2"></category></entry><entry><title>From MacVim to terminal vim</title><link href="http://blog.roseman.org.uk/2010/12/15/macvim-terminal-vim/" rel="alternate"></link><updated>2010-12-15T06:18:09+00:00</updated><author><name>Daniel Roseman</name></author><id>http://blog.roseman.org.uk/2010/12/15/macvim-terminal-vim/</id><summary type="html">&lt;p&gt;I'm a very happy user of MacVim, which very nicely integrates vim into a native Mac app. But occasionally I need to edit code via a terminal, which means dropping back to plain old vim. Recently I found myself working on a project that was distributed on a self-contained virtual machine, and after several days of mucking around with mounting the VM's filesystem via &lt;code&gt;sshfs&lt;/code&gt; and suffering continued networking drop-outs, I decided to bite the bullet and move to working entirely within the terminal.&lt;/p&gt;
&lt;p&gt;Mostly, the transition was fairly simple. I was able to copy over my &lt;code&gt;.vimrc&lt;/code&gt; and the contents of the &lt;code&gt;.vim&lt;/code&gt; directory to my home directory on the VM, and almost everything 'just worked'. There were a few exceptions.&lt;/p&gt;
&lt;p&gt;The first thing that I missed was the mouse. Although like any good vim user I do stay mainly on the keyboard, it's nice to have the mouse available occasionally as an alternative for things like rapid scrolling with the wheel, tab/window switching, and text selection. I initially thought I would just have to do without, but it turns out that it is quite possible to have the mouse working within the terminal. &lt;/p&gt;
&lt;p&gt;The main issue is that although there is a well-defined way for an xterm terminal to send mouse events, the OSX Terminal app doesn't support it. However, there is a nice easy hack that does work: &lt;a href="http://bitheap.org/mouseterm/"&gt;MouseTerm&lt;/a&gt;. This is a SIMBL plugin which patches the terminal so it sends mouse events. I already had SIMBL installed, as I use Ciar√°n Walsh's indispensible &lt;a href="http://ciaranwal.sh/2007/11/01/customising-colours-in-leopard-terminal"&gt;TerminalColors&lt;/a&gt; to make the terminal colours sensible, so it was just a matter of clicking the MouseTerm .dmg to get it working. Then I just added &lt;code&gt;set mouse=a&lt;/code&gt; to my .vimrc, and hey presto: mouse in terminal vim.&lt;/p&gt;
&lt;p&gt;Secondly, tabs. I use tabs all the time in vim. MacVim overrides vim's built-in tabs with proper native ones, so that you can open them in the standard way - eg opening documents in new tabs via &lt;code&gt;:tabe&lt;/code&gt; - but then switch between them with the standard OSX shortcut keys, &lt;code&gt;cmd-[&lt;/code&gt; and &lt;code&gt;cmd-]&lt;/code&gt;. In the terminal, the first of these continues to work, but since the tabs are now vim's own ones, switching needs to be done by the vim shortcuts of &lt;code&gt;gt&lt;/code&gt; and &lt;code&gt;gT&lt;/code&gt;. Not too much to learn - I might try and force myself to use those within MacVim, for the sake of consistency.&lt;/p&gt;
&lt;p&gt;Thirdly, extensions. As I said above, most of these just worked by copying over my &lt;code&gt;.vim&lt;/code&gt; directory. But one of the ones I use most of all - the excellent &lt;a href="https://wincent.com/products/command-t"&gt;Command-T&lt;/a&gt; file navigator - did not. This was because the version of vim installed on Ubuntu by default via &lt;code&gt;apt-get install vim&lt;/code&gt; does not include Ruby support, even though it does include most of the other options. Removing that and installing the &lt;code&gt;vim-nox&lt;/code&gt; package instead rectified that.&lt;/p&gt;
&lt;p&gt;The final issue is cursors. MacVim nicely distinguishes between insert and normal mode by switching between bar and block cursors. In the terminal, this doesn't happen. It appears to be possible to send custom escape sequences when switching modes: the &lt;code&gt;termcap-cursor-shape&lt;/code&gt; help topic explains how. But I couldn't get this to work even for the examples in that topic, which switch colour rather than shape; I don't even know how to begin finding the right escape codes to change the cursor shape. In any case, I suspect something in the interface between Terminal.app and the Ubuntu bash shell is preventing colour codes from working - for example, &lt;code&gt;printf "\e[0 32 m"&lt;/code&gt; works in the OSX shell to change the text colour to green, but the same command fails to work when I'm ssh-ed in to the VM. Any hints would be gratefully received.&lt;/p&gt;</summary><category term="vim"></category><category term="macvim"></category><category term="terminal"></category><category term="ubuntu"></category></entry><entry><title>Vim autocomplete, Django and virtualenv</title><link href="http://blog.roseman.org.uk/2010/04/21/vim-autocomplete-django-and-virtualenv/" rel="alternate"></link><updated>2010-04-21T17:41:49+01:00</updated><author><name>Daniel Roseman</name></author><id>http://blog.roseman.org.uk/2010/04/21/vim-autocomplete-django-and-virtualenv/</id><summary type="html">&lt;p&gt;One of the features I quite missed when I first moved from Komodo to Textmate as my main editor was autocompletion. Although I didn't use it very much, it was occasionally useful to be reminded of the methods available on a class, without having to look up the documentation or open the source module.&lt;/p&gt;
&lt;p&gt;Now I've moved to vim, which has its own version of autocomplete: omnicompletion. This is activated by pressing Ctrl-X Ctrl-O in insert mode after typing the name of a class or instance, and displays a nice drop-down menu with all the available members of that object. The Python plugins which come with vim allow this function to not only complete items from the standard library, but also to parse your own files which are open in the editor, reading the modules you import and adding those elements to the completion dictionaries.&lt;/p&gt;
&lt;p&gt;However, this wasn't working for me in my Django projects. After a lot of investigation, I found that this was down to three issues.&lt;/p&gt;
&lt;p&gt;The first two of these related to the fact that I was working within a virtualenv. Despite the fact that I was starting MacVim after activating the virtual environment, the specific site-packages directory was not being added to the path and it was defaulting to the system-wide one, which on my system doesn't contain any of the packages I was using. The solution to this is to use the &lt;code&gt;activate_this.py&lt;/code&gt; script which is provided with virtualenv to activate it within another process - it's intended for use with mod_wsgi, but works just as well here. You can run it from the vim command line, using &lt;code&gt;python&lt;/code&gt; to tell vim that the following commands are in Python. (Note that the Python interpreter is actually persistent, so you can import modules or define variables in one command and they are still available in subsequent ones.)&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="p"&gt;:&lt;/span&gt;python activate_this &lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;/path/to/virtualenv/bin/activate_this.py&amp;#39;&lt;/span&gt;
&lt;span class="p"&gt;:&lt;/span&gt;python execfile&lt;span class="p"&gt;(&lt;/span&gt;activate_this&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nb"&gt;dict&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;__file__&lt;span class="p"&gt;=&lt;/span&gt;activate_this&lt;span class="p"&gt;))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;This sets up the paths properly, but it was still not working. After a lot of investigation, I finally realised that this was because vim uses its own built-in Python interpreter, which is version 2.5, while my Snow Leopard machine was using 2.6. The confusion arose because doing this:&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="p"&gt;:&lt;/span&gt;python import sys; print sys.executable
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;em&gt;does&lt;/em&gt; return the path to my virtualenv's version of Python. To make it even worse, this:&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="p"&gt;:&lt;/span&gt;python print sys.&lt;span class="k"&gt;version&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;returned 2.5.2, when the executable printed in the previous command was actually Python 2.6.1! I can't explain that bit of weirdness, and would be interested to hear in the comments if anyone else can, but the fact that vim was clearly using a 2.5 Python did at least explain why it wasn't picking up the local packages which were installed in the virtualenv's lib/python2.6/site-packages directory.&lt;/p&gt;
&lt;p&gt;The version of Python included is decided at compile time, and the pre-built versions of MacVim are actually compiled against Python 2.5, so to make it work with the 2.6 directories I had to build my own binaries. Luckily this is &lt;a href="http://code.google.com/p/macvim/wiki/Building"&gt;very easy&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;The third and final piece of the puzzle was Django-specific. Anything that uses a Django model, or indeed imports anything that references &lt;code&gt;django.db&lt;/code&gt;, needs a settings module. Normally when running from &lt;code&gt;manage.py&lt;/code&gt; this is set automatically, but obviously that doesn't work within vim. So you just need to set the &lt;code&gt;DJANGO_SETTINGS_MODULE&lt;/code&gt; environment variable, which again can be done from the vim command line:&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="k"&gt;let&lt;/span&gt; $DJANGO_SETTINGS_MODULE&lt;span class="p"&gt;=&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;mysite.settings&amp;#39;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;With all that in place, plus some further Python path manipulation to ensure it found all my project's code, I was now able to complete code within Django projects.&lt;/p&gt;
&lt;p&gt;There's some work to be done to automate this. At the moment, I've put all the above commands into a &lt;code&gt;.vimrc&lt;/code&gt; file at the base of the virtual env, and added some code to my main &lt;code&gt;~/.vimrc&lt;/code&gt; to load it based on the value of the &lt;code&gt;VIRTUAL_ENV&lt;/code&gt; environment variable (which is set by &lt;code&gt;bin/activate&lt;/code&gt;):&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="k"&gt;if&lt;/span&gt; filereadable&lt;span class="p"&gt;(&lt;/span&gt;$VIRTUAL_ENV . &lt;span class="s1"&gt;&amp;#39;/.vimrc&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    source $VIRTUAL_ENV/.vimrc
&lt;span class="k"&gt;endif&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;This probably isn't ideal, as it involves remembering to create that file with all its specific hard-coded paths each time I set up a new virtualenv. On the other hand, trying to do something more automatic will be difficult, as my settings files are not always in a predictable location - eg for work they are often under &lt;code&gt;projectname.configs.development.settings&lt;/code&gt; - so maybe this is the best I can do.&lt;/p&gt;</summary><category term="django"></category><category term="vim"></category><category term="virtualenv"></category><category term="autocomplete"></category></entry><entry><title>Vim taglist and Django</title><link href="http://blog.roseman.org.uk/2009/12/26/vim-taglist-and-django/" rel="alternate"></link><updated>2009-12-26T12:33:41+00:00</updated><author><name>Daniel Roseman</name></author><id>http://blog.roseman.org.uk/2009/12/26/vim-taglist-and-django/</id><summary type="html">&lt;p&gt;Inspired by the &lt;a href="http://www.viemu.com/a_vi_vim_graphical_cheat_sheet_tutorial.html"&gt;graphical cheat sheet here&lt;/a&gt;, I've recently moved over to Vim as my main development environment.&lt;/p&gt;
&lt;p&gt;After installing a whole range of plugins, I found that one of them, taglist, no longer worked with my Django code. The reason was that something was changing the filetype of Django modules to 'python.django', and taglist - unlike most other plugins - was trying to match against the whole filetype, rather than just a part of it.&lt;/p&gt;
&lt;p&gt;My solution is to hack taglist so that it does a partial match on the filetype. In the &lt;code&gt;Tlist_Get_Buffer_Filetype&lt;/code&gt; function (line 984), change&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="k"&gt;let&lt;/span&gt; buf_ft &lt;span class="p"&gt;=&lt;/span&gt; getbufvar&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;a&lt;/span&gt;:bnum&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;&amp;amp;filetype&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;to &lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="k"&gt;let&lt;/span&gt; buf_ft &lt;span class="p"&gt;=&lt;/span&gt; split&lt;span class="p"&gt;(&lt;/span&gt;getbufvar&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;a&lt;/span&gt;:bnum&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;&amp;amp;filetype&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;\.&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;[&lt;span class="m"&gt;0&lt;/span&gt;]
&lt;/pre&gt;&lt;/div&gt;</summary><category term="django"></category><category term="vim"></category></entry></feed>