<!DOCTYPE html>
<html lang="en">
<head>
        <title>rosemanblog - vim</title>
        <meta charset="utf-8" />
        <link rel="stylesheet" href=".././theme/css/main.css" type="text/css" />
        <link href=".././feeds/all.atom.xml" type="application/atom+xml" rel="alternate" title="rosemanblog ATOM Feed" />
        
        <link href=".././feeds/all.xml" type="application/atom+xml" rel="alternate" title="rosemanblog RSS Feed" />
        

        <!--[if IE]>
                <script src="http://html5shiv.googlecode.com/svn/trunk/html5.js"></script><![endif]-->

        <!--[if lte IE 7]>
                <link rel="stylesheet" type="text/css" media="all" href=".././css/ie.css"/>
                <script src=".././js/IE8.js" type="text/javascript"></script><![endif]-->

        <!--[if lt IE 7]>
                <link rel="stylesheet" type="text/css" media="all" href=".././css/ie6.css"/><![endif]-->

</head>

<body id="index" class="home">

        <header id="banner" class="body">
                <h1><a href="../.">rosemanblog </a></h1>
                <nav><ul>
                
                
                
                
                
                    <li ><a href=".././category/Technical.html">Technical</a></li>
                
                </ul></nav>
        </header><!-- /#banner -->
                

            

        
        
            <aside id="featured" class="body">
                <article>
                    <h1 class="entry-title"><a href=".././2013/12/17/a-better-vim-go-to-declaration-with-asts/">A better vim 'go to declaration' with ASTs.</a></h1> 
                    <footer class="post-info">
        <abbr class="published" title="2013-12-17T11:15:00">
                Tue 17 December 2013
        </abbr>

        
        <address class="vcard author">
                By <a class="url fn" href=".././author/Daniel Roseman.html">Daniel Roseman</a>
        </address>
        
<p>In <a href=".././category/Technical.html">Technical</a>. </p>
<p>tags: <a href=".././tag/python.html">python</a> <a href=".././tag/vim.html">vim</a> <a href=".././tag/ast.html">ast</a> </p>


</footer><!-- /.post-info --><p>There are loads of little commands in vim for navigating around your files. One of the ones I like the most is <code>gd</code>, for "go to local declaration". What that does - or is supposed to do - is find the place at which the identifier under the cursor is declared or defined, and go to it. </p>
<p>However, as the documentation states, this is "not guaranteed to work" - and in fact rarely does. The issue is that vim does not parse the code and find the actual definition: what it does it to find the beginning of the current function (which rarely works in Python anyway) or the top of the file, and search forward from there. Even if that did work reliably, it still wouldn't cope with definitions at class or module level, and doesn't distinguish between variables defined at different scopes.</p>
<p>No doubt the proper fix here is to use something like ctags, that processes your file and outputs a tags list that can be used by vim's tag matching. But that still wouldn't really understand scope. Anyway, I wanted to see if this could be done dynamically, by using Python itself to try and extract some meaning from the code, and determine where the variable was actually defined using its understanding of the scope. So, in my insanity, I turned to ASTs.</p>
<p><a href="http://docs.python.org/2/library/ast.html">Abstract Syntax Trees</a> are a way of representing code as a series of objects, arranged in a tree, which represent the language's grammar in an abstract way. Given this simple code:</p>
<div class="codehilite"><pre><span class="k">def</span> <span class="nf">foo</span><span class="p">(</span><span class="n">bar</span><span class="p">):</span>
  <span class="n">baz</span> <span class="o">=</span> <span class="n">bar</span> <span class="o">*</span> <span class="mi">2</span>
  <span class="k">return</span> <span class="n">baz</span>
</pre></div>


<p>and calling <code>ast.parse()</code> on it (as a string), you get this series of objects (reformatted for clarity):</p>
<div class="codehilite"><pre><span class="n">Module</span><span class="p">(</span><span class="n">body</span><span class="o">=</span><span class="p">[</span><span class="n">FunctionDef</span><span class="p">(</span>
    <span class="n">name</span><span class="o">=</span><span class="s">&#39;foo&#39;</span><span class="p">,</span>
    <span class="n">args</span><span class="o">=</span><span class="n">arguments</span><span class="p">(</span>
        <span class="n">args</span><span class="o">=</span><span class="p">[</span><span class="n">Name</span><span class="p">(</span><span class="nb">id</span><span class="o">=</span><span class="s">&#39;bar&#39;</span><span class="p">,</span> <span class="n">ctx</span><span class="o">=</span><span class="n">Param</span><span class="p">())],</span>
        <span class="n">vararg</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">kwarg</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">defaults</span><span class="o">=</span><span class="p">[]),</span>
    <span class="n">body</span><span class="o">=</span><span class="p">[</span>
        <span class="n">Assign</span><span class="p">(</span>
            <span class="n">targets</span><span class="o">=</span><span class="p">[</span><span class="n">Name</span><span class="p">(</span><span class="nb">id</span><span class="o">=</span><span class="s">&#39;baz&#39;</span><span class="p">,</span> <span class="n">ctx</span><span class="o">=</span><span class="n">Store</span><span class="p">())],</span>
            <span class="n">value</span><span class="o">=</span><span class="n">BinOp</span><span class="p">(</span>
                <span class="n">left</span><span class="o">=</span><span class="n">Name</span><span class="p">(</span><span class="nb">id</span><span class="o">=</span><span class="s">&#39;bar&#39;</span><span class="p">,</span> <span class="n">ctx</span><span class="o">=</span><span class="n">Load</span><span class="p">()),</span>
                <span class="n">op</span><span class="o">=</span><span class="n">Mult</span><span class="p">(),</span>
                <span class="n">right</span><span class="o">=</span><span class="n">Num</span><span class="p">(</span><span class="n">n</span><span class="o">=</span><span class="mi">2</span><span class="p">))</span>
        <span class="p">),</span>
        <span class="n">Return</span><span class="p">(</span><span class="n">value</span><span class="o">=</span><span class="n">Name</span><span class="p">(</span><span class="nb">id</span><span class="o">=</span><span class="s">&#39;baz&#39;</span><span class="p">,</span> <span class="n">ctx</span><span class="o">=</span><span class="n">Load</span><span class="p">()))</span>
    <span class="p">],</span> <span class="n">decorator_list</span><span class="o">=</span><span class="p">[]</span>
<span class="p">)])</span>
</pre></div>


<p>That's not particularly easy to read, but you can at least see that it's represented the various identifiers - foo, bar and baz - as objects with attributes defining things like their names, and that the objects form a tree with the Module at the top, a FunctionDef inside that, and then the Assign and Return statements inside the body attribute.</p>
<p>So, it looks like we can use this tree to find the definition of the variable we're on. The process will look like this: first, we need to scan through the tree to find our current file position and locate the AST representation of our current identifier. Then, we need to progressively widen our scope until we find the object that first assigns that identifier. Finally, we can move vim's cursor to that object's position.</p>
<p>The code for doing this is borrowed mainly from the excellent pyflakes project, which uses AST parsing to detect syntax or style errors. (The vim interface code is inspired by the much-lamented pyflakes.vim - I've never got on with Syntastic in quite the same way I did with that). Pyflakes already does a great job of implementing a Visitor class to step through the tree and call relevant methods for each node, so all we need to do is override the relevant methods to search for our identifier, rather than check for style.</p>
<p>Pyflakes also very helpfully keeps track of an object's scope. It uses this to check for errors like identifiers being referenced before they have been defined, or style issues like objects that are defined but never referenced. So, every time the visitor encounters a new definition, it stores it in a dictionary representing the current scope (module, function or class), and whenever it encounters a further use of that identifier, it looks the object up in the scope stack and annotates it with the scope where it was found.</p>
<p>Clearly, that is exactly what we need to implement our 'go to definition' functionality. We just need to override the Visitor methods such that we compare each node with our identifier, and if they match we take that node, find its scope (which has already been recorded by the visitor) and then extract the definition's line/column number from there. Note that when matching, we compare both name and line number - clearly, names can be defined multiple times in a file, and we want the correct node for our target position.</p>
<p>Things are complicated slightly by the fact that our target identifier might not be a Node at all, but an attribute of another node. This happens with dot notation: for example, the attribute reference <code>foo.quux</code> is represented in an AST like this:</p>
<div class="codehilite"><pre><span class="n">Attribute</span><span class="p">(</span><span class="n">value</span><span class="o">=</span><span class="n">Name</span><span class="p">(</span><span class="nb">id</span><span class="o">=</span><span class="s">&#39;baz&#39;</span><span class="p">,</span> <span class="n">ctx</span><span class="o">=</span><span class="n">Load</span><span class="p">()),</span> <span class="n">attr</span><span class="o">=</span><span class="s">&#39;quux&#39;</span><span class="p">,</span> <span class="n">ctx</span><span class="o">=</span><span class="n">Load</span><span class="p">())</span>
</pre></div>


<p>If you were searching for the original definition of the <code>quux</code> attribute, you would need to start from the Attribute node and check for matches to the <code>attr</code> attribute.</p>
<p>We deal with this by overriding both <code>handleChildren</code> and <code>NAME</code> methods from Pyflake's Checker class. The first is called for attributes, and the second for Name nodes, ie everything else. In each one we check the line number, as well as either the <code>id</code> or the <code>attr</code> atribute.</p>
<div class="codehilite"><pre><span class="k">def</span> <span class="nf">handleChildren</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tree</span><span class="p">):</span>
    <span class="k">if</span> <span class="p">(</span><span class="nb">hasattr</span><span class="p">(</span><span class="n">tree</span><span class="p">,</span> <span class="s">&#39;lineno&#39;</span><span class="p">)</span> <span class="ow">and</span> <span class="n">tree</span><span class="o">.</span><span class="n">lineno</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">lineno</span>
        <span class="ow">and</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">tree</span><span class="p">,</span> <span class="s">&#39;attr&#39;</span><span class="p">)</span> <span class="ow">and</span> <span class="n">tree</span><span class="o">.</span><span class="n">attr</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">target</span> <span class="o">=</span> <span class="n">tree</span>
            <span class="n">scope</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getScope</span><span class="p">(</span><span class="n">tree</span><span class="o">.</span><span class="n">attr</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">targetScope</span> <span class="o">=</span> <span class="n">scope</span>

    <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">checker</span><span class="o">.</span><span class="n">iter_child_nodes</span><span class="p">(</span><span class="n">tree</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">handleNode</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">tree</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">NAME</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">):</span>
    <span class="nb">super</span><span class="p">(</span><span class="n">MyChecker</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">NAME</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">node</span><span class="o">.</span><span class="n">lineno</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">lineno</span> <span class="ow">and</span> <span class="n">node</span><span class="o">.</span><span class="n">id</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">:</span>
      <span class="bp">self</span><span class="o">.</span><span class="n">target</span> <span class="o">=</span> <span class="n">node</span>
      <span class="bp">self</span><span class="o">.</span><span class="n">targetScope</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getScope</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">id</span><span class="p">)</span>
</pre></div>


<p>The <code>getScope</code> method is a simple check upwards through the relevant scope objects:</p>
<div class="codehilite"><pre><span class="k">def</span> <span class="nf">getScope</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">target</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">target</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">scope</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">scope</span><span class="p">[</span><span class="n">target</span><span class="p">]</span>
    <span class="k">for</span> <span class="n">scope</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">scopeStack</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">::</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span>
        <span class="k">if</span> <span class="n">target</span> <span class="ow">in</span> <span class="n">scope</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">scope</span><span class="p">[</span><span class="n">target</span><span class="p">]</span>
    <span class="k">print</span> <span class="s">&#39;Sorry, no definition found.&#39;</span>
</pre></div>


<p>All that's left is the wrapper to grab the word under the vim cursor using <code>vim.eval('expand("&lt;cword&gt;")')</code>, pass it to the Checker, extract the target definition, and go to the relevant line/column. One last tiny tweak is that not all nodes have an actual child node for the definition itself - eg the FunctionDef above starts on col 0, but the name itself is on col 4 - so we use a simply Python <code>str.find</code> to move to the actual column position of the name.</p>
<p>Now, of course this is still very far from perfect. It won't resolve names imported via <code>from module import *</code> - but of course no-one would ever use that anyway. Much more seriously though, it can't find names that are defined outside the current scope tree. For example, if you call a method that defines a series of attributes on an object, then return it, and <em>then</em> pass it to another method, inside that second method the scope chain has no record of where the new attributes were originally defined. Similarly, it won't find methods that are defined on an object's superclass. I haven't yet come up with any good way of fixing that, although in practice it doesn't seem to be a huge problem.</p>
<p>You can find the code on <a href="http://github.com/danielroseman/pygd-vim">GitHub</a>.</p><p>There are <a href=".././2013/12/17/a-better-vim-go-to-declaration-with-asts/#disqus_thread">comments</a>.</p>
                </article>
                
            </aside><!-- /#featured -->
            
                <section id="content" class="body">
                    <h1>Other articles</h1>
                    <hr />
                        <ol id="posts-list" class="hfeed">
            
        
        
        
        

        
         
            
            <li><article class="hentry">    
                <header>
                        <h1><a href=".././2012/02/04/improving-vim-terminal-development-environment/" rel="bookmark" title="Permalink to Improving the vim terminal development environment">Improving the vim terminal development environment</a></h1>
                </header>
                
                <div class="entry-content">
                <footer class="post-info">
        <abbr class="published" title="2012-02-04T14:21:27">
                Sat 04 February 2012
        </abbr>

        
        <address class="vcard author">
                By <a class="url fn" href=".././author/Daniel Roseman.html">Daniel Roseman</a>
        </address>
        
<p>In <a href=".././category/Technical.html">Technical</a>. </p>
<p>tags: <a href=".././tag/vim.html">vim</a> <a href=".././tag/iterm2.html">iterm2</a> </p>


</footer><!-- /.post-info -->
                <p>Since I started working at Google, I've been doing almost all my development using vim through the terminal. Since <a href="../static/2010/12/15/macvim-terminal-vim">my last post</a> on the subject (over a year ago - bad blogger), I've discovered some significant improvements to what I recommended there, and I thought I'd share what ...</p>
                <a class="readmore" href=".././2012/02/04/improving-vim-terminal-development-environment/">read more</a>
                <p>There are <a href=".././2012/02/04/improving-vim-terminal-development-environment/#disqus_thread">comments</a>.</p>
                </div><!-- /.entry-content -->
            </article></li>
        
        
        

        
         
            
            <li><article class="hentry">    
                <header>
                        <h1><a href=".././2010/12/15/macvim-terminal-vim/" rel="bookmark" title="Permalink to From MacVim to terminal vim">From MacVim to terminal vim</a></h1>
                </header>
                
                <div class="entry-content">
                <footer class="post-info">
        <abbr class="published" title="2010-12-15T06:18:09">
                Wed 15 December 2010
        </abbr>

        
        <address class="vcard author">
                By <a class="url fn" href=".././author/Daniel Roseman.html">Daniel Roseman</a>
        </address>
        
<p>In <a href=".././category/Technical.html">Technical</a>. </p>
<p>tags: <a href=".././tag/vim.html">vim</a> <a href=".././tag/macvim.html">macvim</a> <a href=".././tag/terminal.html">terminal</a> <a href=".././tag/ubuntu.html">ubuntu</a> </p>


</footer><!-- /.post-info -->
                <p>I'm a very happy user of MacVim, which very nicely integrates vim into a native Mac app. But occasionally I need to edit code via a terminal, which means dropping back to plain old vim. Recently I found myself working on a project that was distributed on a self-contained ...</p>
                <a class="readmore" href=".././2010/12/15/macvim-terminal-vim/">read more</a>
                <p>There are <a href=".././2010/12/15/macvim-terminal-vim/#disqus_thread">comments</a>.</p>
                </div><!-- /.entry-content -->
            </article></li>
        
        
        

        
         
            
            <li><article class="hentry">    
                <header>
                        <h1><a href=".././2010/04/21/vim-autocomplete-django-and-virtualenv/" rel="bookmark" title="Permalink to Vim autocomplete, Django and virtualenv">Vim autocomplete, Django and virtualenv</a></h1>
                </header>
                
                <div class="entry-content">
                <footer class="post-info">
        <abbr class="published" title="2010-04-21T17:41:49">
                Wed 21 April 2010
        </abbr>

        
        <address class="vcard author">
                By <a class="url fn" href=".././author/Daniel Roseman.html">Daniel Roseman</a>
        </address>
        
<p>In <a href=".././category/Technical.html">Technical</a>. </p>
<p>tags: <a href=".././tag/django.html">django</a> <a href=".././tag/vim.html">vim</a> <a href=".././tag/virtualenv.html">virtualenv</a> <a href=".././tag/autocomplete.html">autocomplete</a> </p>


</footer><!-- /.post-info -->
                <p>One of the features I quite missed when I first moved from Komodo to Textmate as my main editor was autocompletion. Although I didn't use it very much, it was occasionally useful to be reminded of the methods available on a class, without having to look up the documentation ...</p>
                <a class="readmore" href=".././2010/04/21/vim-autocomplete-django-and-virtualenv/">read more</a>
                <p>There are <a href=".././2010/04/21/vim-autocomplete-django-and-virtualenv/#disqus_thread">comments</a>.</p>
                </div><!-- /.entry-content -->
            </article></li>
        
        
        

        
         
            
            <li><article class="hentry">    
                <header>
                        <h1><a href=".././2009/12/26/vim-taglist-and-django/" rel="bookmark" title="Permalink to Vim taglist and Django">Vim taglist and Django</a></h1>
                </header>
                
                <div class="entry-content">
                <footer class="post-info">
        <abbr class="published" title="2009-12-26T12:33:41">
                Sat 26 December 2009
        </abbr>

        
        <address class="vcard author">
                By <a class="url fn" href=".././author/Daniel Roseman.html">Daniel Roseman</a>
        </address>
        
<p>In <a href=".././category/Technical.html">Technical</a>. </p>
<p>tags: <a href=".././tag/django.html">django</a> <a href=".././tag/vim.html">vim</a> </p>


</footer><!-- /.post-info -->
                <p>Inspired by the <a href="http://www.viemu.com/a_vi_vim_graphical_cheat_sheet_tutorial.html">graphical cheat sheet here</a>, I've recently moved over to Vim as my main development environment.</p>
<p>After installing a whole range of plugins, I found that one of them, taglist, no longer worked with my Django code. The reason was that something was changing the filetype of ...</p>
                <a class="readmore" href=".././2009/12/26/vim-taglist-and-django/">read more</a>
                <p>There are <a href=".././2009/12/26/vim-taglist-and-django/#disqus_thread">comments</a>.</p>
                </div><!-- /.entry-content -->
            </article></li>
        
        
            
<p class="paginator">
    
    Page 1 / 1
    
</p>

        

    
    </ol><!-- /#posts-list -->
    </section><!-- /#content -->



        <section id="extras" class="body">
        
        
                <div class="social">
                        <h2>social</h2>
                        <ul>
                            <li><a href=".././feeds/all.atom.xml" rel="alternate">atom feed</a></li>
                            
                            <li><a href=".././feeds/all.xml" rel="alternate">rss feed</a></li>
                            

                        
                            <li><a href="http://twitter.com/danielroseman">twitter</a></li>
                        
                            <li><a href="http://github.com/danielroseman">github</a></li>
                        
                        </ul>
                </div><!-- /.social -->
        
        </section><!-- /#extras -->

        <footer id="contentinfo" class="body">
                <address id="about" class="vcard body">
                Proudly powered by <a href="http://alexis.notmyidea.org/pelican/">pelican</a>, which takes great advantages of <a href="http://python.org">python</a>.
                </address><!-- /#about -->

                <p>The theme is by <a href="http://coding.smashingmagazine.com/2009/08/04/designing-a-html-5-layout-from-scratch/">Smashing Magazine</a>, thanks!</p>
        </footer><!-- /#contentinfo -->




<script type="text/javascript">
    var disqus_shortname = 'rosemanblog';
    (function () {
        var s = document.createElement('script'); s.async = true;
        s.type = 'text/javascript';
        s.src = 'http://' + disqus_shortname + '.disqus.com/count.js';
        (document.getElementsByTagName('HEAD')[0] || document.getElementsByTagName('BODY')[0]).appendChild(s);
    }());
</script>

</body>
</html>