<!DOCTYPE html>
<html lang="en">
<head>
        <meta charset="utf-8" />
        <title>rosemanblog - queryset</title>
        <link rel="stylesheet" href="http://blog.roseman.org.uk/theme/css/main.css" />
        <link href="http://blog.roseman.org.uk/feeds/all.atom.xml" type="application/atom+xml" rel="alternate" title="rosemanblog Atom Feed" />

        <!--[if IE]>
            <script src="http://html5shiv.googlecode.com/svn/trunk/html5.js"></script>
        <![endif]-->
</head>

<body id="index" class="home">
        <header id="banner" class="body">
                <h1><a href="http://blog.roseman.org.uk/">rosemanblog </a></h1>
                <nav><ul>
                    <li><a href="http://blog.roseman.org.uk/category/technical.html">Technical</a></li>
                </ul></nav>
        </header><!-- /#banner -->

            <aside id="featured" class="body">
                <article>
                    <h1 class="entry-title"><a href="http://blog.roseman.org.uk/2012/05/30/querysets-arent-as-lazy-as-you-think/">Querysets aren't as lazy as you think</a></h1>
<footer class="post-info">
        <abbr class="published" title="2012-05-30T20:30:00">
                Wed 30 May 2012
        </abbr>

        <address class="vcard author">
                By <a class="url fn" href="http://blog.roseman.org.uk/author/daniel-roseman.html">Daniel Roseman</a>
        </address>
<p>In <a href="http://blog.roseman.org.uk/category/technical.html">Technical</a>. </p>
<p>tags: <a href="http://blog.roseman.org.uk/tag/django.html">django</a><a href="http://blog.roseman.org.uk/tag/queryset.html">queryset</a></p>
</footer><!-- /.post-info --><p>It should be reasonably well-known by now that querysets are lazy. That is, simply instantiating a queryset via a manager doesn't actually hit the database: that doesn't happen until the queryset is sliced or iterated. That's why the first field definition in the form below is safe, but not the second:</p>
<div class="highlight"><pre><span class="n">class</span> <span class="n">MyForm</span><span class="p">(</span><span class="n">forms</span><span class="p">.</span><span class="n">Form</span><span class="p">)</span><span class="o">:</span>
    <span class="n">my_field</span> <span class="o">=</span> <span class="n">forms</span><span class="p">.</span><span class="n">ModelChoiceField</span><span class="p">(</span><span class="n">queryset</span><span class="o">=</span><span class="n">MyModel</span><span class="p">.</span><span class="n">objects</span><span class="p">.</span><span class="n">all</span><span class="p">())</span>
    <span class="n">my_datefield</span> <span class="o">=</span> <span class="n">forms</span><span class="p">.</span><span class="n">DateTimeField</span><span class="p">(</span><span class="n">initial</span><span class="o">=</span><span class="n">datetime</span><span class="p">.</span><span class="n">datetime</span><span class="p">.</span><span class="n">now</span><span class="p">())</span>
</pre></div>


<p>Even though both elements are calling methods on definition, the first is safe because the queryset is not evaluated at that time, whereas the second is not safe because it <em>is</em> evaluated at that time, and therefore remains the same for the duration of the current process (which can be many days). For the record, you should always pass the <em>callable</em>: <code>initial=datetime.datetime.now</code>, without the calling brackets.</p>
<p>Now, there are a couple of gotchas here. It is perfectly possible to define manager methods that are not safe to use in places like the <code>queryset</code> argument to the first field above. Here's an example:</p>
<div class="highlight"><pre><span class="n">class</span> <span class="n">PublishedManager</span><span class="p">(</span><span class="n">models</span><span class="p">.</span><span class="n">Manager</span><span class="p">)</span><span class="o">:</span>
    <span class="n">def</span> <span class="n">get_query_set</span><span class="p">(</span><span class="n">self</span><span class="p">)</span><span class="o">:</span>
        <span class="k">return</span> <span class="n">super</span><span class="p">(</span><span class="n">PublishedManager</span><span class="p">,</span> <span class="n">self</span><span class="p">).</span><span class="n">get_query_set</span><span class="p">().</span><span class="n">filter</span><span class="p">(</span>
                <span class="n">published_date__lte</span><span class="o">=</span><span class="n">datetime</span><span class="p">.</span><span class="n">datetime</span><span class="p">.</span><span class="n">now</span><span class="p">())</span>
</pre></div>


<p>Clearly, this is an attempt to create a manager that automatically filters items which have been published. In the normal course of calling this in a view, it will work exactly as expected. But if you passed it into the <code>queryset</code> parameter of the form field, the same thing will happen as with the date field: the cut-off point will always be set when the form is first imported, and will persist for the life of the process.</p>
<p>This is because there's nothing magical about manager methods that makes them lazy. The laziness comes further down, inside the QuerySet class itself. This method, which is called automatically by the <code>all()</code> method, will be evaluated when it is called - ie when the form is first defined. At that point, the right-hand-side of the query expression will also be evaluated, and passed into the main Manager <code>get_query_set</code> method. So no matter when you instantiate your form after this, during the lifetime of the process you will never see any objects whose <code>published_date</code> is greater than the first time.</p>
<p>But note that if you change the <code>published_date</code> of an existing object to before that time - or even create a new object with that date - you <em>will</em> see it. The queryset is still lazy, and the database will be queried each time the form is instantiated: but that <code>published_date</code> parameter is fixed.</p><p>There are <a href="http://blog.roseman.org.uk/2012/05/30/querysets-arent-as-lazy-as-you-think/#disqus_thread">comments</a>.</p>                </article>
<p class="paginator">
    Page 1 / 1
</p>
            </aside><!-- /#featured -->
            </ol><!-- /#posts-list -->
            </section><!-- /#content -->
        <section id="extras" class="body">
                <div class="social">
                        <h2>social</h2>
                        <ul>
                            <li><a href="http://blog.roseman.org.uk/feeds/all.atom.xml" type="application/atom+xml" rel="alternate">atom feed</a></li>

                            <li><a href="http://twitter.com/danielroseman">twitter</a></li>
                            <li><a href="http://github.com/danielroseman">github</a></li>
                            <li><a href="http://stackoverflow.com/users/104349/daniel-roseman">stackoverflow</a></li>
                        </ul>
                </div><!-- /.social -->
        </section><!-- /#extras -->

        <footer id="contentinfo" class="body">
                <address id="about" class="vcard body">
                Proudly powered by <a href="http://getpelican.com/">Pelican</a>, which takes great advantage of <a href="http://python.org">Python</a>.
                </address><!-- /#about -->

                <p>The theme is by <a href="http://coding.smashingmagazine.com/2009/08/04/designing-a-html-5-layout-from-scratch/">Smashing Magazine</a>, thanks!</p>
        </footer><!-- /#contentinfo -->

<script type="text/javascript">
    var disqus_shortname = 'rosemanblog';
    (function () {
        var s = document.createElement('script'); s.async = true;
        s.type = 'text/javascript';
        s.src = 'http://' + disqus_shortname + '.disqus.com/count.js';
        (document.getElementsByTagName('HEAD')[0] || document.getElementsByTagName('BODY')[0]).appendChild(s);
    }());
</script>
</body>
</html>